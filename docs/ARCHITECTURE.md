# Архитектура Envedour Bot

Детальное описание архитектуры системы, компонентов и их взаимодействия.

## Содержание

- [Обзор архитектуры](#обзор-архитектуры)
- [Трехслойная архитектура](#трехслойная-архитектура)
- [Interface Layer](#interface-layer)
- [Queue Layer](#queue-layer)
- [Executor Layer](#executor-layer)
- [Взаимодействие компонентов](#взаимодействие-компонентов)
- [Потоки данных](#потоки-данных)
- [Обработка ошибок](#обработка-ошибок)
- [Масштабируемость](#масштабируемость)

## Обзор архитектуры

Envedour Bot построен по **трехслойной архитектуре** с четким разделением ответственности:

```
┌─────────────────────────────────────────────────┐
│           Telegram Bot API                        │
│         (Локальный или облачный)                 │
└──────────────────┬──────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────┐
│         Interface Layer (Bot)                   │
│  - Обработка обновлений                         │
│  - Валидация URL                                 │
│  - Управление настройками                      │
│  - Создание клавиатур                           │
└──────────────────┬──────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────┐
│         Queue Layer (Redis)                     │
│  - Распределенная очередь                      │
│  - Приоритизация задач                         │
│  - Хранение настроек                           │
└──────────────────┬──────────────────────────────┘
                   │
┌──────────────────▼──────────────────────────────┐
│         Executor Layer                          │
│  - Скачивание медиа (yt-dlp)                    │
│  - Обработка (FFmpeg)                          │
│  - Отправка файлов                             │
│  - Мониторинг ресурсов                         │
└─────────────────────────────────────────────────┘
```

## Трехслойная архитектура

### Принципы

1. **Разделение ответственности**: Каждый слой отвечает за свою область
2. **Слабая связанность**: Слои взаимодействуют через четкие интерфейсы
3. **Масштабируемость**: Каждый слой может масштабироваться независимо
4. **Отказоустойчивость**: Ошибки изолируются на уровне слоя

### Преимущества

- **Простота поддержки**: Четкое разделение кода
- **Тестируемость**: Каждый слой тестируется отдельно
- **Расширяемость**: Легко добавлять новые функции
- **Производительность**: Оптимизация каждого слоя независимо

## Interface Layer

**Расположение**: `internal/bot/`

### Компоненты

#### bot.go

Основная логика обработки обновлений от Telegram.

**Функции**:
- Инициализация Bot API
- Обработка входящих обновлений
- Маршрутизация команд и сообщений
- Управление callback queries

**Ключевые методы**:
```go
Start(ctx context.Context)        // Запуск обработки обновлений
handleUpdate(update *Update)       // Обработка одного обновления
handleCommand(msg *Message)        // Обработка команд
handleURL(msg *Message)           // Обработка URL
handleCallback(callback *Callback) // Обработка callback queries
```

#### keyboard.go

Создание интерактивных клавиатур.

**Функции**:
- Создание главного меню
- Создание меню качества
- Создание меню типа медиа
- Создание клавиатуры выбора качества при скачивании

**Особенность**: Использование `jobID` вместо полного URL в callback data для обхода ограничения Telegram (64 байта).

#### preferences.go

Управление пользовательскими настройками.

**Функции**:
- Сохранение настроек качества
- Сохранение типа медиа
- Временное хранение URL (для callback queries)
- Получение сохраненных настроек

**Хранение**: Redis с TTL 30 дней

### Поток обработки обновления

```
1. Получение обновления от Telegram Bot API
   ↓
2. Определение типа обновления
   ├─ Команда → handleCommand()
   ├─ URL → handleURL()
   └─ Callback → handleCallback()
   ↓
3. Валидация и обработка
   ↓
4. Создание задачи (если нужно)
   ↓
5. Добавление в очередь
   ↓
6. Отправка ответа пользователю
```

### Особенности

- **Worker pool**: Параллельная обработка обновлений
- **Временное хранение URL**: В Redis для callback queries
- **Автоматическое определение платформы**: По URL
- **Приоритизация**: Определение доноров

## Queue Layer

**Расположение**: `internal/queue/`

### Компоненты

#### queue.go

Распределенная очередь задач на базе Redis.

**Структура задачи (Job)**:
```go
type Job struct {
    ID        string    // Уникальный ID задачи
    URL       string    // URL для скачивания
    ChatID    int64     // Chat ID пользователя
    Priority  Priority  // Приоритет (High/Low)
    Quality   string    // Качество видео
    MediaType string    // Тип медиа (video/audio)
    CreatedAt  time.Time // Время создания
}
```

**Методы**:
```go
Enqueue(job *Job) error           // Добавление в очередь
Dequeue(ctx context.Context) (*Job, error) // Извлечение из очереди
GetClient() *redis.Client        // Получение Redis клиента
```

### Реализация очереди

#### Структура в Redis

```
job_queue (List)          # Основная очередь задач
  ├─ job_1 (JSON)
  ├─ job_2 (JSON)
  └─ job_3 (JSON)

preferences:{chatID} (Hash) # Настройки пользователя
  ├─ quality: "1080p"
  └─ media_type: "video"

pending_url:{jobID} (String) # Временные URL для callback
  └─ "https://youtube.com/..."
```

#### Приоритизация

- **High Priority**: Добавляются в начало очереди (LPUSH)
- **Low Priority**: Добавляются в конец очереди (RPUSH)
- **Извлечение**: Всегда из начала (LPOP)

### Особенности

- **Атомарные операции**: Использование Redis транзакций
- **FIFO**: First In, First Out для одинакового приоритета
- **Автоматическая очистка**: TTL для временных данных
- **Масштабируемость**: Поддержка множественных воркеров

## Executor Layer

**Расположение**: `internal/executor/`

### Компоненты

#### executor.go

Основная логика выполнения задач.

**Функции**:
- Скачивание медиа через yt-dlp
- Использование aria2c для ускорения
- Обработка через FFmpeg
- Отправка файлов пользователям
- Управление памятью
- Проверка ресурсов

**Ключевые методы**:
```go
Worker(ctx context.Context, q Queue)  // Воркер для обработки задач
processJob(ctx context.Context, job *Job) // Обработка одной задачи
downloadMedia(ctx, url, jobID, quality, mediaType) // Скачивание
sendVideo(chatID, videoPath)          // Отправка видео
sendAudio(chatID, audioPath)           // Отправка аудио
checkMemory() error                   // Проверка памяти
```

#### executor_thermal.go

Термальный мониторинг (только для ARM64).

**Функции**:
- Мониторинг температуры CPU
- Throttling при перегреве
- Автоматическое восстановление

**Условия компиляции**: `// +build arm64`

#### checks.go

Проверка окружения.

**Функции**:
- Валидация зависимостей (yt-dlp, aria2c, FFmpeg)
- Проверка tmpfs
- Проверка прав доступа

### Поток обработки задачи

```
1. Извлечение задачи из очереди
   ↓
2. Проверка термального состояния (ARM64)
   ├─ Перегрев → Re-enqueue с задержкой
   └─ Норма → Продолжить
   ↓
3. Проверка доступной памяти
   ├─ Недостаточно → Ошибка пользователю
   └─ Достаточно → Продолжить
   ↓
4. Определение платформы по URL
   ↓
5. Настройка yt-dlp параметров
   ├─ TikTok → Специальные headers и настройки
   ├─ Instagram → Cookies и настройки
   ├─ YouTube → Стандартные настройки
   └─ Другие → Базовые настройки
   ↓
6. Скачивание медиа
   ├─ Видео → yt-dlp с форматом
   └─ Аудио → yt-dlp с извлечением MP3
   ↓
7. Обработка файла (если нужно)
   └─ FFmpeg для конвертации
   ↓
8. Проверка размера файла
   ├─ Превышен лимит → Ошибка
   └─ В пределах → Продолжить
   ↓
9. Отправка файла пользователю
   ├─ Видео → sendVideo()
   └─ Аудио → sendAudio()
   ↓
10. Очистка временных файлов
```

### Платформо-специфичные настройки

#### TikTok

- **Headers**: Специальные заголовки для обхода защиты
- **User-Agent**: Chrome 131.0.0.0
- **Cookies**: Обязательны
- **curl-cffi**: Для TLS fingerprinting
- **IPv4**: Принудительное использование IPv4

#### Instagram

- **Cookies**: Обязательны
- **Стандартные настройки**: Базовые параметры yt-dlp

#### YouTube

- **Cookies**: Опциональны
- **Форматы**: Гибкий выбор качества
- **Аудио**: Поддержка извлечения MP3

### Управление ресурсами

#### Память

- **Проверка перед загрузкой**: `checkMemory()`
- **Минимальная свободная память**: Настраивается через `MIN_FREE_MEM_MB`
- **Ограничение Go heap**: `GOMEMLIMIT=512MiB`

#### Температура (ARM64)

- **Мониторинг**: Каждые 5 секунд
- **Порог**: 85°C
- **Действие**: Приостановка обработки
- **Восстановление**: Автоматическое при снижении температуры

#### Временные файлы

- **Хранение**: tmpfs (`/dev/shm/videos`)
- **Автоматическая очистка**: После отправки файла
- **Размер tmpfs**: 2GB (настраивается)

## Взаимодействие компонентов

### Последовательность операций

```
Пользователь → Telegram → Bot API → Interface Layer
                                              ↓
                                    Создание задачи
                                              ↓
                                    Queue Layer (Redis)
                                              ↓
                                    Executor Layer
                                              ↓
                                    yt-dlp → aria2c → FFmpeg
                                              ↓
                                    Bot API → Telegram → Пользователь
```

### Асинхронная обработка

```
Interface Layer (goroutine)
    ↓ (async)
Queue Layer (Redis)
    ↓ (async)
Executor Layer (worker pool)
    ↓ (async)
Отправка файла
```

## Потоки данных

### Входящий поток (Пользователь → Бот)

```
1. Пользователь отправляет URL
   ↓
2. Telegram Bot API получает сообщение
   ↓
3. Bot API отправляет обновление боту
   ↓
4. Interface Layer обрабатывает обновление
   ↓
5. Создается задача (Job)
   ↓
6. Задача добавляется в Redis очередь
```

### Исходящий поток (Бот → Пользователь)

```
1. Executor извлекает задачу из очереди
   ↓
2. Скачивание и обработка медиа
   ↓
3. Файл готов к отправке
   ↓
4. Executor отправляет файл через Bot API
   ↓
5. Bot API отправляет файл в Telegram
   ↓
6. Пользователь получает файл
```

### Поток настроек

```
1. Пользователь выбирает качество через кнопку
   ↓
2. Interface Layer получает callback
   ↓
3. Настройки сохраняются в Redis
   ↓
4. При следующем скачивании настройки загружаются
   ↓
5. Используются при создании задачи
```

## Обработка ошибок

### Уровни обработки

1. **Interface Layer**:
   - Валидация URL
   - Проверка формата сообщения
   - Ошибки отправляются пользователю

2. **Queue Layer**:
   - Ошибки подключения к Redis
   - Ошибки сериализации
   - Retry логика

3. **Executor Layer**:
   - Ошибки скачивания
   - Ошибки обработки
   - Ошибки отправки
   - Все ошибки логируются и отправляются пользователю

### Типичные ошибки

- **Неверный URL**: Валидация на Interface Layer
- **Недостаточно памяти**: Проверка перед загрузкой
- **Перегрев**: Throttling на Executor Layer
- **Ошибка скачивания**: Логирование и уведомление пользователя
- **Файл слишком большой**: Проверка размера перед отправкой

## Масштабируемость

### Горизонтальное масштабирование

- **Interface Layer**: Может запускаться в нескольких экземплярах
- **Queue Layer**: Redis поддерживает множественных клиентов
- **Executor Layer**: Worker pool может масштабироваться

### Вертикальное масштабирование

- **Увеличение WORKER_COUNT**: Больше параллельных задач
- **Увеличение памяти**: Больше файлов одновременно
- **Оптимизация CPU**: Использование всех ядер

### Ограничения

- **Redis**: Единственная точка входа (можно использовать кластер)
- **tmpfs**: Ограничен размером RAM
- **CPU**: Ограничен количеством ядер
- **Сеть**: Ограничена пропускной способностью

---

**Следующий шаг**: См. [PERFORMANCE.md](PERFORMANCE.md) для оптимизации
